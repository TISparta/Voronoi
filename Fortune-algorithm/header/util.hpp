#pragma once

#include <iostream>
#include <random>
#include <unistd.h>

#include "Arguments.hpp"
#include "Event.hpp"

namespace util {

const float INF = 1e9;
const float EPS = 1e-6;

/**
 * Returns true if 'x' and 'y' are equal
 */
template <typename T>
bool IS_EQ (T x, T y)
{
  return std::fabs (y - x) < EPS;
}

/**
 * Returns a random number in [l, r)
 */
template <typename T>
static T random_real (int l, int r)
{
  std::mt19937 rng;
  rng.seed (std::random_device ()());
  std::uniform_real_distribution <> distribution(l, r);
  return distribution (rng);
}

/**
 * Returns a random point whose coordinates are in [l, r)
 */
template <typename T>
static Point <T> random_point (int l, int r) {
  return Point <T> (random_real <T> (l, r), random_real <T> (l, r));
}

/**
 * Show help for using command line options
 */
void show_help ()
{
  puts ("./voronoi [options]");
  puts ("Options");
  puts ("\t -n <number points>");
  puts ("\t -w <width>");
  puts ("\t -h <height>");
  puts ("\t -c <number threads>");
  exit (-1);
}

/**
 * Parses the arguments and saves them
 */
template <typename T>
static void parse_arguments (int argc, char** argv, Arguments <T>& arg)
{ 
  int option;
  while (true) {
    option = getopt (argc, argv, "n:w:h:c:-");
    if (option == -1) break;
    switch (option) {
      case 'n':
        arg.n_points = atoi(optarg);
        break;
      case 'w':
        arg.width = atoi(optarg);
        break;
      case 'h':
        arg.height = atoi(optarg);
        break;
      case 'c':
        arg.n_threads = atoi(optarg);
        break;
      case '-':
        show_help ();
      case '?':
        std::cout << "Unknow option\n";
        show_help ();
    }
  }
}

/**
 * Generates 'n_sites' points in 'sites'
 */
template <typename T>
void generate_random_sites (int n_sites, int min_val, int max_val,
                            std::vector <Point <T>>& sites)
{
  sites.clear ();
  for (int i = 0; i < n_sites; i++) {
    sites.push_back (random_point <T> (min_val, max_val));
  }
}

/**
 * Compute the intersection point of two parabolas with directriz x
 */
template <typename T>
Point <T> compute_parabolas_intersection (Point <T> p0, Point <T> p1, T x)
{
  Point <T> res;
  Point <T> p;
  if (IS_EQ <T> (p0.x, p1.x)) {
    res.y = (p0.y + p1.y) / 2;
  } else if (IS_EQ <T> (p1.x, x)) {
    res.y = p1.y;
  } else if (IS_EQ <T> (p0.x, x)) {
    res.y = p0.y;
    p = p1;
  } else {
    T z0 = 2 * (p0.x - x);
    T z1 = 2 * (p1.x - x);
    T a = 1.0 / z0 - 1.0 / z1;
    T b = -2 * (p0.y / z0 - p1.y / z1);
    T c = (p0.y * p0.y + p0.x + p0.x - x * x) / z0 - 
          (p1.y * p1.y + p1.x + p1.x - x * x) / z1;
    res.y = (-b - std::sqrt (b * b - 4 * a * c)) / (2 * a);
  }
  res.x = (p.x * p.x + (p.y - res.y) * (p.y - res.y) - x * x) / (2 * p.x - 2 * x);
  return res;
}

/**
 * Intersect 'arc' with the degenerated parabola produced by 'p' and save the
 * result in 'res'
 */
template <typename T>
bool intersect (Point <T> p, Arc <T>* arc, Point <T>& res)
{
  if (IS_EQ <T> (arc->p.x, p.x)) return false;
  double l = INF;
  double r = INF;
  if (arc->prev) l = compute_parabolas_intersection <T> (arc->prev->p, arc->p, p.x).y;
  if (arc->next) r = compute_parabolas_intersection <T> (arc->p, arc->next->p, p.x).y;
  if (l <= p.y and p.y <= r) {
    res.y = p.y;
    res.x = (arc->p.x * arc->p.x + (arc->p.y - res.y) * (arc->p.y - res.y) - p.x * p.x) 
              / (2 * arc->p.x - 2 * p.x);
    return true;
  }
  return false;
}

/**
 * Check if the circle generated by 'a', 'b', 'c' produces an event
 */
template <typename T>
bool generate_circle_event (Point <T> a, Point <T> b, Point <T> c, T& x, Point <T>& o)
{
  // Check that bc is a "right turn" from ab
  if ((b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y) > 0) return false;

  // Algorithm from O'Rourke 2ed p. 189
  T A = b.x - a.x;
  T B = b.y - a.y;
  T C = c.x - a.x;
  T D = c.y - a.y;
  T E = A * (a.x + b.x) + B * (a.y + b.y),
  F = C * (a.x + c.x) + D * (a.y + c.y),
  G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));
  
  if (IS_EQ <T> (G, 0)) return false;
  o.x = (D * E - B * F) / G;
  o.y = (A * F - C * E) / G;
  x = o.x + sqrt (std::pow(a.x - o.x, 2) + pow(a.y - o.y, 2));
  return true;
}

}
